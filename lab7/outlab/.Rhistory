# For both X = 15 and X = 10
for(i in 2:length(secondScores$x)) {
## For X = 15
if(secondScores$x[i] < secondScores$x[i-1])  {            # be either decreasing or equal
secondScores$ranks[i] = i
}
else {
secondScores$ranks[i] = secondScores$ranks[i-1]
}
## For X = 10
if(secondScoresX_10$x[i] < secondScoresX_10$x[i-1])  {            # be either decreasing or equal
secondScoresX_10$ranks[i] = i
}
else {
secondScoresX_10$ranks[i] = secondScoresX_10$ranks[i-1]
}
}
## print second Scores
printTopRanks(secondScores)
printTopRanks(secondScoresX_10)
ninv12_X15 = inversions(firstScores,secondScores)
ninv12_X10 = inversions(firstScores,secondScoresX_10)
cat('No. of inversions:', ninv12_X15,'\n')
cat('No. of inversions:', ninv12_X10,'\n')
## ndata is used for the 4 bin system
## Third part, put into bins!
## Already normalized data
## thirdScores[[i]][[j]] = ith company, jth bin
X = 15
n = 15
ndata = vdata       # use original data to standardize
## Normalise columns '4' bins at a time
for(icol in (seq(1,ncol,4))) {
# vctr.mu = vctr.sum/vctr.num
# vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
normalisedVector = c(unlist(ndata[[icol]]),unlist(ndata[[icol+1]]),unlist(ndata[[icol+2]]),unlist(ndata[[icol+3]]))
vctr.mu = mean(normalisedVector,na.rm = TRUE)
vctr.stdev = sd(normalisedVector,na.rm = TRUE)
for(j in 0:3) {
ndata[[icol+j]] = normalize(ndata[[icol+j]],vctr.mu,vctr.stdev)
ndata[[icol+j]] = normalize(ndata[[icol+j]],-6,0.1)
}
}
thirdScores = list()
thirdScoresX_10 = list()
# find the max 15 scores here
## find the top X scores
for(i in (1:nentries)){
## thirdScores (n=15)
rowScore = sort(unlist(sapply(ndata,function(x) x[[i]])),decreasing=TRUE)
if(length(rowScore) < n) {
thirdScores[[i]] = -Inf
}
else {
thirdScores[[i]] = sum(rowScore[1:n])
}
## n = 10
if(length(rowScore) < n-5) {
thirdScoresX_10[[i]] = -Inf
}
else {
thirdScoresX_10[[i]] = sum(rowScore[1:(n-5)])
}
}
#find topRanks after filtering
thirdScores = sort(unlist(thirdScores),decreasing =TRUE,index.return=TRUE)
thirdScoresX_10 = sort(unlist(thirdScoresX_10),decreasing =TRUE,index.return=TRUE)
#determine ranks
thirdScores = determineRanks(thirdScores)
thirdScoresX_10 = determineRanks(thirdScoresX_10)
# print Rank3
printTopRanks(thirdScores)
printTopRanks(thirdScoresX_10)
#### The Shapiro Wilk test on all columns
countNormalDist = 0
for(i in 1:ncol) {
pval = shapiro.test(unlist(vdata[[i]]))$p.value
if(pval > 0.02) {
countNormalDist = countNormalDist + 1
}
}
cat(1-countNormalDist/ncol,'fraction is NOT normally distributed.\n')
#### The Shapiro Wilk test for four columns at once
countNormalDist = 0
for(i in seq(1,ncol,4)) {
v = unlist(vdata[[i]])
for(j in 1:3) {
v = c(v , unlist(vdata[[i+j]]) )
}
pval = shapiro.test(v)$p.value
if(pval > 0.02) {
countNormalDist = countNormalDist + 1
}
}
cat(1-countNormalDist/(ncol/4),'fraction is NOT normally distributed. (in bins of 4)\n')
rawdata = (read.csv("mutualFundPerformance.csv",header=FALSE))
ncol = length(rawdata)
nentries = length(rawdata[[1]])
lmax = 1
X = 15
#loads rawdata into usable format udata
#converts each cell to list
lister = function(x){
if(class(x)=="numeric" || class(x)=="logical") return(x)
if(x=="") return(NA)
stripped = strsplit(x,'\"')[[1]]
charlist = strsplit(stripped[length(stripped)],' ')
retvalue = (lapply(charlist, as.numeric))[[1]]
lmax = max(lmax,length(retvalue))
return(retvalue)
}
# Determine ranks
determineRanks = function(values) {
values$ranks = c(1)
for(i in 2:length(values$x)) {
if(values$x[i] < values$x[i-1])  {            # be either decreasing or equal
values$ranks[i] = i
}
else {
values$ranks[i] = values$ranks[i-1]
}
}
values      ## Supposed to return the value
}
# return column converted into usable format
colproc = function(col){
if(class(col)=="factor"){
lolol = (lapply(col,function(x) lister(levels(factor(x))))) #listoflistoflist
lmax = max(lmax,length(lolol))
return(lolol)
}
else{
lolol = (lapply(col,list))
lmax = max(lmax,length(lolol))
return(lapply(lolol,function(x) x[1][[1]]))
}
}
printTopRanks = function(values) {
for(i in 1:nentries) {
if(values$x[i] > -Inf) {
if(values$ranks[i] > X) {
break
}
else{
cat(values$ix[i],values$x[i],'\n')
}
}
else
break
}
cat('\n')
}
# Inversions
inversions = function(left,right) {
nl = sum(sapply(left$x,function(t) t>-Inf))
nr = sum(sapply(right$x,function(t) t>-Inf))
# rank of left$x[[i]]=left$rank[[i]], index of left$x[[i]]=left$ix[[i]]
if(nl < nr) return(inversions(right,left))
truerankl = list()
for(i in 1:nl){
truerankl[[left$ix[[i]]]] = left$rank[[i]]
}
ninv = 0
for(i in 1:nr){
for(j in i+1:nl){
if(j>nl) break
if((right$rank[[i]]>right$rank[[j]] && truerankl[[right$ix[[i]]]]< truerankl[[right$ix[[j]]]]) || (right$rank[[i]]<right$rank[[j]] && truerankl[[right$ix[[i]]]]> truerankl[[right$ix[[j]]]])) ninv = ninv+1
}
}
return(ninv)
}
vdata = udata = lapply((1:length(rawdata)),function(x) colproc(rawdata[[x]]))
# Normalization, x can be list, array or anything else
normalize = function(x,mu,stdev){
if(class(x)=="logical") return(NA)
if(class(x)=="list") return(lapply(x,function(x) normalize(x,mu,stdev)))
return ((x-mu)/stdev)
}
# length of x of any list
mylength = function(x){
if(class(x[[1]])=="logical"){return(0)}
else{return(length(x))}
}
## Normalise columns individually
for(icol in (1:ncol)) {
v = unlist(udata[[icol]])
vctr.mu = mean(v , na.rm = T)
vctr.stdev = sd(v,na.rm = T)
udata[[icol]] = normalize(udata[[icol]],vctr.mu,vctr.stdev)
udata[[icol]] = normalize(udata[[icol]],-6,0.1)
}
###################################################################################################
# Ranking 1
# Give the non-NA entries for the list
## Find average company score from norm/stand mydata
avgCompanyScore = function(values,mydata) {
for(i in (1:nentries)){
values[[i]] = sum(sapply(mydata,function(x) sum(unlist(x[[i]]),na.rm=TRUE)),na.rm=TRUE)   ## extract rows
entry.num  = sum(unlist(sapply(mydata,function(x) {       ## sum of values
if(is.na(x[[i]][1])) {
0
}
else {
length(x[[i]])
}
})),na.rm=TRUE)
values[[i]] = values[[i]] / entry.num           ## Average
if(entry.num == 0)
values[[i]] = NA
}
values
}
#### Top n companies
topNScores = function(values,mydata,Nval) {
for(i in 1:nentries) {
rowScore = sort(unlist(sapply(mydata,function(x) x[[i]])),decreasing=TRUE)      # extract rows
if(length(rowScore) < Nval) {                                                   # if length < 15 or 10, give it sum of -Inf
values[[i]] = -Inf
}
else {
values[[i]] = sum(rowScore[1:Nval])
}
}
values
}
countnum = function(x){
return(sum(unlist(lapply(x,is.numeric))))
}
X=15
firstScores = list()
firstScores = avgCompanyScore(firstScores,udata)
firstScores
firstScores = sort(unlist(firstScores),decreasing =TRUE,index.return=TRUE)
firstScores
firstScores = determineRanks(firstScores)
printTopRanks(firstScores)
# Ranking2
# Give best-n normalised scores
udata = normalize(udata,60,10)  # normalize the scores from standarised data
X=15
secondScores = list()           # list to insert -Inf or total score of 1:n
secondScoresX_10 = list()
## find the top X scores
secondScores = topNScores(secondScores,udata,15)
secondScoresX_10 = topNScores(secondScoresX_10,udata,10)
secondScores = sort(unlist(secondScores),decreasing =TRUE,index.return=TRUE)
secondScoresX_10 = sort(unlist(secondScoresX_10),decreasing =TRUE,index.return=TRUE)
secondScores$ranks = c(1)
secondScoresX_10$ranks = c(1)
# determine ranks
# For both X = 15 and X = 10
secondScores = determineRanks(secondScores)
secondScoresX_10 = determineRanks(secondScoresX_10)
## print second Scores
printTopRanks(secondScores)
printTopRanks(secondScoresX_10)
ninv12_X15 = inversions(firstScores,secondScores)
ninv12_X10 = inversions(firstScores,secondScoresX_10)
cat('No. of inversions:', ninv12_X15,'\n')
cat('No. of inversions:', ninv12_X10,'\n')
## ndata is used for the 4 bin system
## Third part, put into bins!
## Already normalized data
## thirdScores[[i]][[j]] = ith company, jth bin
X = 15
n = 15
ndata = vdata
# use original data to standardize
## Normalise columns '4' bins at a time
for(icol in (seq(1,ncol,4))) {
normalisedVector = c(unlist(ndata[[icol]]),unlist(ndata[[icol+1]]),unlist(ndata[[icol+2]]),unlist(ndata[[icol+3]]))
vctr.mu = mean(normalisedVector,na.rm = TRUE)
vctr.stdev = sd(normalisedVector,na.rm = TRUE)
for(j in 0:3) {
ndata[[icol+j]] = normalize(ndata[[icol+j]],vctr.mu,vctr.stdev)
ndata[[icol+j]] = normalize(ndata[[icol+j]],-6,0.1)
}
}
thirdScores = list()
thirdScoresX_10 = list()
## find the top X scores
thirdScores = topNScores(thirdScores,ndata,15)
thirdScoresX_10 = topNScores(thirdScoresX_10,ndata,10)
#find topRanks after filtering
thirdScores = sort(unlist(thirdScores),decreasing =TRUE,index.return=TRUE)
thirdScoresX_10 = sort(unlist(thirdScoresX_10),decreasing =TRUE,index.return=TRUE)
#determine ranks
thirdScores = determineRanks(thirdScores)
thirdScoresX_10 = determineRanks(thirdScoresX_10)
# print Rank3
printTopRanks(thirdScores)
printTopRanks(thirdScoresX_10)
inversions(secondScores,thirdScores)
inversions(secondScoresX_10,thirdScoresX_10)
rm(list=ls())
rawdata = (read.csv("mutualFundPerformance.csv",header=FALSE))
ncol = length(rawdata)
nentries = length(rawdata[[1]])
lmax = 1
X = 15
#loads rawdata into usable format udata
#converts each cell to list
lister = function(x){
if(class(x)=="numeric" || class(x)=="logical") return(x)
if(x=="") return(NA)
stripped = strsplit(x,'\"')[[1]]
charlist = strsplit(stripped[length(stripped)],' ')
retvalue = (lapply(charlist, as.numeric))[[1]]
lmax = max(lmax,length(retvalue))
return(retvalue)
}
# Determine ranks
determineRanks = function(values) {
values$ranks = c(1)
for(i in 2:length(values$x)) {
if(values$x[i] < values$x[i-1])  {            # be either decreasing or equal
values$ranks[i] = i
}
else {
values$ranks[i] = values$ranks[i-1]
}
}
values      ## Supposed to return the value
}
# return column converted into usable format
colproc = function(col){
if(class(col)=="factor"){
lolol = (lapply(col,function(x) lister(levels(factor(x))))) #listoflistoflist
lmax = max(lmax,length(lolol))
return(lolol)
}
else{
lolol = (lapply(col,list))
lmax = max(lmax,length(lolol))
return(lapply(lolol,function(x) x[1][[1]]))
}
}
printTopRanks = function(values) {
for(i in 1:nentries) {
if(values$x[i] > -Inf) {
if(values$ranks[i] > X) {
break
}
else{
cat(values$ix[i],values$x[i],'\n')
}
}
else
break
}
cat('\n')
}
# Inversions
inversions = function(left,right) {
nl = sum(sapply(left$x,function(t) t>-Inf))
nr = sum(sapply(right$x,function(t) t>-Inf))
# rank of left$x[[i]]=left$rank[[i]], index of left$x[[i]]=left$ix[[i]]
if(nl < nr) return(inversions(right,left))
truerankl = list()
for(i in 1:nl){
truerankl[[left$ix[[i]]]] = left$rank[[i]]
}
ninv = 0
for(i in 1:nr){
for(j in i+1:nl){
if(j>nl) break
if((right$rank[[i]]>right$rank[[j]] && truerankl[[right$ix[[i]]]]< truerankl[[right$ix[[j]]]]) || (right$rank[[i]]<right$rank[[j]] && truerankl[[right$ix[[i]]]]> truerankl[[right$ix[[j]]]])) ninv = ninv+1
}
}
return(ninv)
}
vdata = udata = lapply((1:length(rawdata)),function(x) colproc(rawdata[[x]]))
# Normalization, x can be list, array or anything else
normalize = function(x,mu,stdev){
if(class(x)=="logical") return(NA)
if(class(x)=="list") return(lapply(x,function(x) normalize(x,mu,stdev)))
return ((x-mu)/stdev)
}
# length of x of any list
mylength = function(x){
if(class(x[[1]])=="logical"){return(0)}
else{return(length(x))}
}
## Normalise columns individually
for(icol in (1:ncol)) {
v = unlist(udata[[icol]])
vctr.mu = mean(v , na.rm = T)
vctr.stdev = sd(v,na.rm = T)
udata[[icol]] = normalize(udata[[icol]],vctr.mu,vctr.stdev)
udata[[icol]] = normalize(udata[[icol]],-6,0.1)
}
###################################################################################################
# Ranking 1
# Give the non-NA entries for the list
## Find average company score from norm/stand mydata
avgCompanyScore = function(values,mydata) {
for(i in (1:nentries)){
values[[i]] = sum(sapply(mydata,function(x) sum(unlist(x[[i]]),na.rm=TRUE)),na.rm=TRUE)   ## extract rows
entry.num  = sum(unlist(sapply(mydata,function(x) {       ## sum of values
if(is.na(x[[i]][1])) {
0
}
else {
length(x[[i]])
}
})),na.rm=TRUE)
values[[i]] = values[[i]] / entry.num           ## Average
if(entry.num == 0)
values[[i]] = NA
}
values
}
#### Top n companies
topNScores = function(values,mydata,Nval) {
for(i in 1:nentries) {
rowScore = sort(unlist(sapply(mydata,function(x) x[[i]])),decreasing=TRUE)      # extract rows
if(length(rowScore) < Nval) {                                                   # if length < 15 or 10, give it sum of -Inf
values[[i]] = -Inf
}
else {
values[[i]] = sum(rowScore[1:Nval])
}
}
values
}
countnum = function(x){
return(sum(unlist(lapply(x,is.numeric))))
}
X=15
firstScores = list()
firstScores = avgCompanyScore(firstScores,udata)
firstScores = sort(unlist(firstScores),decreasing =TRUE,index.return=TRUE)
firstScores = determineRanks(firstScores)
printTopRanks(firstScores)
# Ranking2
# Give best-n normalised scores
udata = normalize(udata,60,10)  # normalize the scores from standarised data
X=15
secondScores = list()           # list to insert -Inf or total score of 1:n
secondScoresX_10 = list()
## find the top X scores
secondScores = topNScores(secondScores,udata,15)
secondScoresX_10 = topNScores(secondScoresX_10,udata,10)
secondScores = sort(unlist(secondScores),decreasing =TRUE,index.return=TRUE)
secondScoresX_10 = sort(unlist(secondScoresX_10),decreasing =TRUE,index.return=TRUE)
secondScores$ranks = c(1)
secondScoresX_10$ranks = c(1)
# determine ranks
# For both X = 15 and X = 10
secondScores = determineRanks(secondScores)
secondScoresX_10 = determineRanks(secondScoresX_10)
## print second Scores
printTopRanks(secondScores)
printTopRanks(secondScoresX_10)
ninv12_X15 = inversions(firstScores,secondScores)
ninv12_X10 = inversions(firstScores,secondScoresX_10)
cat('No. of inversions:', ninv12_X15,'\n')
cat('No. of inversions:', ninv12_X10,'\n')
## ndata is used for the 4 bin system
## Third part, put into bins!
## Already normalized data
## thirdScores[[i]][[j]] = ith company, jth bin
X = 15
n = 15
ndata = vdata
# use original data to standardize
## Normalise columns '4' bins at a time
for(icol in (seq(1,ncol,4))) {
normalisedVector = c(unlist(ndata[[icol]]),unlist(ndata[[icol+1]]),unlist(ndata[[icol+2]]),unlist(ndata[[icol+3]]))
vctr.mu = mean(normalisedVector,na.rm = TRUE)
vctr.stdev = sd(normalisedVector,na.rm = TRUE)
for(j in 0:3) {
ndata[[icol+j]] = normalize(ndata[[icol+j]],vctr.mu,vctr.stdev)
ndata[[icol+j]] = normalize(ndata[[icol+j]],-6,0.1)
}
}
thirdScores = list()
thirdScoresX_10 = list()
## find the top X scores
thirdScores = topNScores(thirdScores,ndata,15)
thirdScoresX_10 = topNScores(thirdScoresX_10,ndata,10)
#find topRanks after filtering
thirdScores = sort(unlist(thirdScores),decreasing =TRUE,index.return=TRUE)
thirdScoresX_10 = sort(unlist(thirdScoresX_10),decreasing =TRUE,index.return=TRUE)
#determine ranks
thirdScores = determineRanks(thirdScores)
thirdScoresX_10 = determineRanks(thirdScoresX_10)
# print Rank3
printTopRanks(thirdScores)
printTopRanks(thirdScoresX_10)
#### The Shapiro Wilk test on all columns
countNormalDist = 0
for(i in 1:ncol) {
pval = shapiro.test(unlist(vdata[[i]]))$p.value
if(pval > 0.02) {
countNormalDist = countNormalDist + 1
}
}
cat(1-countNormalDist/ncol,'fraction is NOT normally distributed.\n')
#### The Shapiro Wilk test for four columns at once
countNormalDist = 0
for(i in seq(1,ncol,4)) {
v = unlist(vdata[[i]])
for(j in 1:3) {
v = c(v , unlist(vdata[[i+j]]) )
}
pval = shapiro.test(v)$p.value
if(pval > 0.02) {
countNormalDist = countNormalDist + 1
}
}
cat(1-countNormalDist/(ncol/4),'fraction is NOT normally distributed. (in bins of 4)\n')
