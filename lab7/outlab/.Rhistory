}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[icol]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(sapply(cell,function(x) x**2))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[icol]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(unlist(lapply(cell,function(x) x**2)))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
View(udata)
udata[[1]]
udata[[2]]
rawdata = as.list(read.csv("mutualFundPerformance.csv",header=FALSE))
ncol = length(rawdata)
nentries = length(rawdata[[1]])
lmax = 1 #max no. of values in cell
#loads rawdata into usable format udata{
#converts each cell to list{
lister = function(x){
if(class(x)=="numeric" || class(x)=="logical") return(x)
if(x=="") return(NA)
stripped = strsplit(x,'\"')[[1]]
charlist = strsplit(stripped[length(stripped)],' ')
retvalue = (lapply(charlist, as.numeric))[[1]]
lmax = max(lmax,length(retvalue))
return(retvalue)
}
#}
colproc = function(col){
if(class(col)=="factor"){
lolol = (lapply(col,function(x) lister(levels(factor(x))))) #listoflistoflist
lmax = max(lmax,length(lolol))
return(lolol)
#return(lapply(lolol,function(x) x[1][[1]]))
}
else{
lolol = (lapply(col,list))
lmax = max(lmax,length(lolol))
#return(lolol)
return(lapply(lolol,function(x) x[1][[1]]))
}
}
udata = lapply((1:length(rawdata)),function(x) colproc(rawdata[[x]]))
#}
#Normalization{
normalize = function(x,mu,stdev){
if(class(x)=="logical") return(NA)
if(class(x)=="list") return(lapply(x,function(x) normalize(x,mu,stdev)))
return ((x-mu)/stdev)
}
mylength = function(x){
if(class(x)=="logical"){return(0)}
else{return(length(x))}
}
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[icol]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(unlist(lapply(cell,function(x) x**2)))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
udata[[1]]
udata[[1]]==NaN
is.nan(udata[[1]])
is.na(udata[[1]])
class(NaN)
is.logical(udata[[1]])
is.logical(udata[[1]])
is.logical(udata[[1]][[2]])
is.logical(udata[[1]][[3]])
is.logical(udata[[1]][[4]])
udata[[1]][[2]]
udata[[2]][[3]]
rawdata = as.list(read.csv("mutualFundPerformance.csv",header=FALSE))
ncol = length(rawdata)
nentries = length(rawdata[[1]])
lmax = 1 #max no. of values in cell
#loads rawdata into usable format udata{
#converts each cell to list{
lister = function(x){
if(class(x)=="numeric" || class(x)=="logical") return(x)
if(x=="") return(NA)
stripped = strsplit(x,'\"')[[1]]
charlist = strsplit(stripped[length(stripped)],' ')
retvalue = (lapply(charlist, as.numeric))[[1]]
lmax = max(lmax,length(retvalue))
return(retvalue)
}
#}
colproc = function(col){
if(class(col)=="factor"){
lolol = (lapply(col,function(x) lister(levels(factor(x))))) #listoflistoflist
lmax = max(lmax,length(lolol))
return(lolol)
#return(lapply(lolol,function(x) x[1][[1]]))
}
else{
lolol = (lapply(col,list))
lmax = max(lmax,length(lolol))
#return(lolol)
return(lapply(lolol,function(x) x[1][[1]]))
}
}
udata = lapply((1:length(rawdata)),function(x) colproc(rawdata[[x]]))
#}
#Normalization{
normalize = function(x,mu,stdev){
if(class(x)=="logical") return(NA)
if(class(x)=="list") return(lapply(x,function(x) normalize(x,mu,stdev)))
return ((x-mu)/stdev)
}
mylength = function(x){
if(class(x)=="logical"){return(0)}
else{return(length(x))}
}
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[icol]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(unlist(lapply(cell,function(x) x**2)))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
print(vctr.stdev)
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
udata[[4]][[2]]
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[icol]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(lapply(cell,function(x) x**2))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
icol = 2
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[icol]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(lapply(cell,function(x) x**2))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
for(cell in udata[4]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(unlist(lapply(cell,function(x) x**2)))
}
}
udata[4]
udata[[4]]
rawdata = as.list(read.csv("mutualFundPerformance.csv",header=FALSE))
ncol = length(rawdata)
nentries = length(rawdata[[1]])
lmax = 1 #max no. of values in cell
#loads rawdata into usable format udata{
#converts each cell to list{
lister = function(x){
if(class(x)=="numeric" || class(x)=="logical") return(x)
if(x=="") return(NA)
stripped = strsplit(x,'\"')[[1]]
charlist = strsplit(stripped[length(stripped)],' ')
retvalue = (lapply(charlist, as.numeric))[[1]]
lmax = max(lmax,length(retvalue))
return(retvalue)
}
#}
colproc = function(col){
if(class(col)=="factor"){
lolol = (lapply(col,function(x) lister(levels(factor(x))))) #listoflistoflist
lmax = max(lmax,length(lolol))
return(lolol)
#return(lapply(lolol,function(x) x[1][[1]]))
}
else{
lolol = (lapply(col,list))
lmax = max(lmax,length(lolol))
#return(lolol)
return(lapply(lolol,function(x) x[1][[1]]))
}
}
udata = lapply((1:length(rawdata)),function(x) colproc(rawdata[[x]]))
#}
#Normalization{
normalize = function(x,mu,stdev){
if(class(x)=="logical") return(NA)
if(class(x)=="list") return(lapply(x,function(x) normalize(x,mu,stdev)))
return ((x-mu)/stdev)
}
mylength = function(x){
if(class(x)=="logical"){return(0)}
else{return(length(x))}
}
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[[icol]]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(unlist(lapply(cell,function(x) x**2)))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
print(vctr.stdev)
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
}
#}
udata
rawdata = as.list(read.csv("mutualFundPerformance.csv",header=FALSE))
ncol = length(rawdata)
nentries = length(rawdata[[1]])
lmax = 1 #max no. of values in cell
#loads rawdata into usable format udata{
#converts each cell to list{
lister = function(x){
if(class(x)=="numeric" || class(x)=="logical") return(x)
if(x=="") return(NA)
stripped = strsplit(x,'\"')[[1]]
charlist = strsplit(stripped[length(stripped)],' ')
retvalue = (lapply(charlist, as.numeric))[[1]]
lmax = max(lmax,length(retvalue))
return(retvalue)
}
#}
colproc = function(col){
if(class(col)=="factor"){
lolol = (lapply(col,function(x) lister(levels(factor(x))))) #listoflistoflist
lmax = max(lmax,length(lolol))
return(lolol)
#return(lapply(lolol,function(x) x[1][[1]]))
}
else{
lolol = (lapply(col,list))
lmax = max(lmax,length(lolol))
#return(lolol)
return(lapply(lolol,function(x) x[1][[1]]))
}
}
udata = lapply((1:length(rawdata)),function(x) colproc(rawdata[[x]]))
#}
#Normalization{
normalize = function(x,mu,stdev){
if(class(x)=="logical") return(NA)
if(class(x)=="list") return(lapply(x,function(x) normalize(x,mu,stdev)))
return ((x-mu)/stdev)
}
mylength = function(x){
if(class(x)=="logical"){return(0)}
else{return(length(x))}
}
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[[icol]]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(unlist(lapply(cell,function(x) x**2)))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
udata[icol] = normalize(udata[icol],-6,0.1)
}
#}
score[i]
score = list()
score[10]
for(i in (1:nentries)){
score[i] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]])))))
}
score
for(i in (1:nentries)){
score[i] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]]),na.rm=TRUE))),na.rm=TRUE)
}
score
sort(score)
countnum = function(x){
return(sum(unlist(lapply(x,is.numeric))))
}
X=15
for(i in (1:nentries)){
score[i] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]]),na.rm=TRUE))),na.rm=TRUE)
entry.num = sum(unlist(sapply(udata,function(x) countnum(x[[i]]))),na.rm=TRUE)
}
score
sort.list(score)
sort(unlist(score))
score(order())
score[order()]
score[order()]
score[1:5]
find(scores,1)
find(score,1)
help(find)
help(Find)
Find(score,1)
Find(unlist(score),1)
help(sort)
sortedscore = sort(unlist(score),descending=TRUE, index.return = TRUE)
sortedscore = sort(unlist(score),descending=TRUE)
sortedscore = sort(unlist(score),descending=TRUE)
sortedscore = sort(unlist(score),descending=TRUE)
score
sortedscore = sort(unlist(score))
sortedscore
sortedscore = sort(unlist(score),decreasing = TRUE, index.return = TRUE)
sort()
sortedscore
sortedscore = sort(unlist(score),descending=TRUE,index.return=TRUE)$ix
sortedscore = sort(unlist(score),decreasing =TRUE,index.return=TRUE)$ix
sortedscore
rawdata = as.list(read.csv("mutualFundPerformance.csv",header=FALSE))
ncol = length(rawdata)
nentries = length(rawdata[[1]])
lmax = 1 #max no. of values in cell
#loads rawdata into usable format udata{
#converts each cell to list{
lister = function(x){
if(class(x)=="numeric" || class(x)=="logical") return(x)
if(x=="") return(NA)
stripped = strsplit(x,'\"')[[1]]
charlist = strsplit(stripped[length(stripped)],' ')
retvalue = (lapply(charlist, as.numeric))[[1]]
lmax = max(lmax,length(retvalue))
return(retvalue)
}
#}
colproc = function(col){
if(class(col)=="factor"){
lolol = (lapply(col,function(x) lister(levels(factor(x))))) #listoflistoflist
lmax = max(lmax,length(lolol))
return(lolol)
#return(lapply(lolol,function(x) x[1][[1]]))
}
else{
lolol = (lapply(col,list))
lmax = max(lmax,length(lolol))
#return(lolol)
return(lapply(lolol,function(x) x[1][[1]]))
}
}
udata = lapply((1:length(rawdata)),function(x) colproc(rawdata[[x]]))
#}
#Normalization{
normalize = function(x,mu,stdev){
if(class(x)=="logical") return(NA)
if(class(x)=="list") return(lapply(x,function(x) normalize(x,mu,stdev)))
return ((x-mu)/stdev)
}
mylength = function(x){
if(class(x)=="logical"){return(0)}
else{return(length(x))}
}
for(icol in (1:ncol)){
vctr.sum = 0
vctr.num = 0
vctr.sqsum = 0
for(cell in udata[[icol]]){
if(!is.na(cell[1])){
vctr.num = vctr.num + length(cell)
vctr.sum = vctr.sum + sum(unlist(cell))
vctr.sqsum = vctr.sqsum + sum(unlist(lapply(cell,function(x) x**2)))
}
}
vctr.mu = vctr.sum/vctr.num
vctr.stdev = sqrt((vctr.sqsum/vctr.num - vctr.mu**2))
udata[icol] = normalize(udata[icol],vctr.mu,vctr.stdev)
udata[icol] = normalize(udata[icol],-6,0.1)
}
#}
countnum = function(x){
return(sum(unlist(lapply(x,is.numeric))))
}
X=15
for(i in (1:nentries)){
score[i] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]]),na.rm=TRUE))),na.rm=TRUE)
entry.num = sum(unlist(sapply(udata,function(x) countnum(x[[i]]))),na.rm=TRUE)
}
sortedscore = sort(unlist(score),decreasing =TRUE,index.return=TRUE)$ix
for(i in (1:X)){
cat(sortedscore[i],score[sortedscore[i]],"\n")
}
for(i in (X+1):nentries){
if(score[sortedscore[i]]!=score[sortedscore[X]]) break
else cat(sortedscore[i],score[sortedscore[i]],"\n")
}
sore[2]
score[2]
class(score[2])
X=15
for(i in (1:nentries)){
score[[i]] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]]),na.rm=TRUE))),na.rm=TRUE)
entry.num = sum(unlist(sapply(udata,function(x) countnum(x[[i]]))),na.rm=TRUE)
}
score
sort(score)
sort(unlist(score))
X=15
for(i in (1:nentries)){
score[[i]] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]]),na.rm=TRUE))),na.rm=TRUE)
entry.num = sum(unlist(sapply(udata,function(x) countnum(x[[i]]))),na.rm=TRUE)
}
sortedscore = sort(unlist(score),decreasing =TRUE,index.return=TRUE)$ix
for(i in (1:X)){
cat(sortedscore[i],score[sortedscore[i]],"\n")
}
for(i in (X+1):nentries){
if(score[[sortedscore[i]]]!=score[[sortedscore[X]]]) break
else cat(sortedscore[i],score[[sortedscore[i]]],"\n")
}
for(i in (1:nentries)){
score[[i]] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]]),na.rm=TRUE))),na.rm=TRUE)
entry.num = sum(unlist(sapply(udata,function(x) countnum(x[[i]]))),na.rm=TRUE)
}
sortedscore = sort(unlist(score),decreasing =TRUE,index.return=TRUE)$ix
for(i in (1:X)){
cat(sortedscore[[i]],score[sortedscore[i]],"\n")
}
for(i in (X+1):nentries){
if(score[[sortedscore[i]]]!=score[[sortedscore[X]]]) break
else cat(sortedscore[[i]],score[[sortedscore[i]]],"\n")
}
score[[3]]
class(score[[3]])
for(i in (1:nentries)){
score[[i]] = sum(unlist(sapply(udata,function(x) sum(unlist(x[[i]]),na.rm=TRUE))),na.rm=TRUE)
entry.num = sum(unlist(sapply(udata,function(x) countnum(x[[i]]))),na.rm=TRUE)
}
sortedscore = sort(unlist(score),decreasing =TRUE,index.return=TRUE)$ix
for(i in (1:X)){
cat(sortedscore[i],score[[sortedscore[i]]],"\n")
}
for(i in (X+1):nentries){
if(score[[sortedscore[i]]]!=score[[sortedscore[X]]]) break
else cat(sortedscore[i],score[[sortedscore[i]]],"\n")
}
X=15
n=10
udata = normalize(udata,60,10)
(list(1,2),(list(3,4)))
list((list(1,2)),(list(3,4)))
c((list(1,2)),(list(3,4)))
c()
